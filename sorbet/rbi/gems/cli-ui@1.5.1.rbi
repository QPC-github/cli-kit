# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-ui` gem.
# Please instead update this file by running `bin/tapioca gem cli-ui`.

module CLI; end

module CLI::UI
  class << self
    def ask(question, **kwargs); end
    def confirm(question, **kwargs); end
    def enable_color=(bool); end
    def enable_color?; end
    def fmt(input, enable_color: T.unsafe(nil)); end
    def frame(*args, **kwargs, &block); end
    def frame_style=(frame_style); end
    def glyph(handle); end
    def log_output_to(path); end
    def puts(msg, **kwargs); end
    def raw; end
    def resolve_color(input); end
    def resolve_style(input); end
    def resolve_text(input, truncate_to: T.unsafe(nil)); end
    def spinner(*args, **kwargs, &block); end
    def with_frame_color(color, &block); end
    def wrap(input); end
  end
end

module CLI::UI::ANSI
  class << self
    def clear_to_end_of_line; end
    def control(args, cmd); end
    def cursor_back(n = T.unsafe(nil)); end
    def cursor_down(n = T.unsafe(nil)); end
    def cursor_forward(n = T.unsafe(nil)); end
    def cursor_horizontal_absolute(n = T.unsafe(nil)); end
    def cursor_restore; end
    def cursor_save; end
    def cursor_up(n = T.unsafe(nil)); end
    def hide_cursor; end
    def next_line; end
    def previous_line; end
    def printing_width(str); end
    def sgr(params); end
    def show_cursor; end
    def strip_codes(str); end
  end
end

CLI::UI::ANSI::ESC = T.let(T.unsafe(nil), String)

class CLI::UI::Color
  def initialize(sgr, name); end

  def code; end
  def name; end
  def sgr; end

  class << self
    def available; end
    def lookup(name); end
  end
end

CLI::UI::Color::BLUE = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::BOLD = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::CYAN = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::GRAY = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::GREEN = T.let(T.unsafe(nil), CLI::UI::Color)

class CLI::UI::Color::InvalidColorName < ::ArgumentError
  def initialize(name); end

  def message; end
end

CLI::UI::Color::MAGENTA = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::MAP = T.let(T.unsafe(nil), Hash)
CLI::UI::Color::RED = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::RESET = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::WHITE = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::YELLOW = T.let(T.unsafe(nil), CLI::UI::Color)

class CLI::UI::Formatter
  def initialize(text); end

  def format(sgr_map = T.unsafe(nil), enable_color: T.unsafe(nil)); end

  private

  def apply_format(text, fmt, sgr_map); end
  def emit(text, stack); end
  def parse_body(sc, stack = T.unsafe(nil)); end
  def parse_expr(sc, stack); end
end

CLI::UI::Formatter::BEGIN_EXPR = T.let(T.unsafe(nil), String)
CLI::UI::Formatter::DISCARD_BRACES = T.let(T.unsafe(nil), Range)
CLI::UI::Formatter::END_EXPR = T.let(T.unsafe(nil), String)

class CLI::UI::Formatter::FormatError < ::StandardError
  def initialize(message = T.unsafe(nil), input = T.unsafe(nil), index = T.unsafe(nil)); end

  def index; end
  def index=(_arg0); end
  def input; end
  def input=(_arg0); end
end

CLI::UI::Formatter::LITERAL_BRACES = T.let(T.unsafe(nil), Symbol)
CLI::UI::Formatter::SCAN_BODY = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_FUNCNAME = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_GLYPH = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_WIDGET = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SGR_MAP = T.let(T.unsafe(nil), Hash)

module CLI::UI::Frame
  class << self
    def close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil)); end
    def divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil)); end
    def frame_style; end
    def frame_style=(frame_style); end
    def open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil)); end
    def prefix(color: T.unsafe(nil)); end
    def prefix_width; end
    def with_frame_color_override(color); end

    private

    def elasped(start, timing); end
  end
end

module CLI::UI::Frame::FrameStack
  class << self
    def items; end
    def pop; end
    def push(item = T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end

    private

    def serialize(items); end
  end
end

CLI::UI::Frame::FrameStack::COLOR_ENVVAR = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStack::STYLE_ENVVAR = T.let(T.unsafe(nil), String)

class CLI::UI::Frame::FrameStack::StackItem
  def initialize(color_name, style_name); end

  def color; end
  def frame_style; end
end

module CLI::UI::Frame::FrameStyle
  class << self
    def extended(base); end
    def loaded_styles; end
    def lookup(name); end
  end
end

module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle
  extend ::CLI::UI::Frame::FrameStyle::Interface

  class << self
    def close(text, color:, right_text: T.unsafe(nil)); end
    def divider(text, color:); end
    def name; end
    def open(text, color:); end
    def prefix; end

    private

    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

CLI::UI::Frame::FrameStyle::Box::BOTTOM_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::DIVIDER = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::HORIZONTAL = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::TOP_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::VERTICAL = T.let(T.unsafe(nil), String)

module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle
  extend ::CLI::UI::Frame::FrameStyle::Interface

  class << self
    def close(text, color:, right_text: T.unsafe(nil)); end
    def divider(text, color:); end
    def name; end
    def open(text, color:); end
    def prefix; end

    private

    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

CLI::UI::Frame::FrameStyle::Bracket::BOTTOM_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::DIVIDER = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::HORIZONTAL = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::TOP_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::VERTICAL = T.let(T.unsafe(nil), String)

module CLI::UI::Frame::FrameStyle::Interface
  def close(text, color:, right_text: T.unsafe(nil)); end
  def divider(text, color: T.unsafe(nil)); end
  def name; end
  def open(text, color:); end
  def prefix; end
  def prefix_width; end

  private

  def print_at_x(x, str); end
end

class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName < ::ArgumentError
  def initialize(name); end

  def message; end
end

class CLI::UI::Frame::UnnestedFrameException < ::StandardError; end

class CLI::UI::Glyph
  def initialize(handle, codepoint, plain, color); end

  def char; end
  def codepoint; end
  def color; end
  def fmt; end
  def handle; end
  def to_s; end

  class << self
    def available; end
    def lookup(name); end
  end
end

CLI::UI::Glyph::BUG = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::CHECK = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::CHEVRON = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::HOURGLASS = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::INFO = T.let(T.unsafe(nil), CLI::UI::Glyph)

class CLI::UI::Glyph::InvalidGlyphHandle < ::ArgumentError
  def initialize(handle); end

  def message; end
end

CLI::UI::Glyph::MAP = T.let(T.unsafe(nil), Hash)
CLI::UI::Glyph::QUESTION = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::STAR = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::WARNING = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::X = T.let(T.unsafe(nil), CLI::UI::Glyph)

module CLI::UI::OS
  class << self
    def current; end
  end
end

class CLI::UI::OS::Linux < ::CLI::UI::OS::Mac; end

class CLI::UI::OS::Mac
  class << self
    def shift_cursor_on_line_reset?; end
    def supports_arrow_keys?; end
    def supports_color_prompt?; end
    def supports_emoji?; end
  end
end

class CLI::UI::OS::Windows
  class << self
    def shift_cursor_on_line_reset?; end
    def supports_arrow_keys?; end
    def supports_color_prompt?; end
    def supports_emoji?; end
  end
end

class CLI::UI::Printer
  class << self
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
  end
end

class CLI::UI::Progress
  def initialize(width: T.unsafe(nil)); end

  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end
  def to_s; end

  class << self
    def progress(width: T.unsafe(nil)); end
  end
end

CLI::UI::Progress::FILLED_BAR = T.let(T.unsafe(nil), String)
CLI::UI::Progress::UNFILLED_BAR = T.let(T.unsafe(nil), String)

module CLI::UI::Prompt
  class << self
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end
    def ask_password(question); end
    def confirm(question, default: T.unsafe(nil)); end

    private

    def ask_free_form(question, default, is_file, allow_empty); end
    def ask_interactive(question, options = T.unsafe(nil), multiple: T.unsafe(nil), default: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil)); end
    def interactive_prompt(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
    def puts_question(str); end
    def readline(is_file: T.unsafe(nil)); end
    def write_default_over_empty_input(default); end
  end
end

class CLI::UI::Prompt::InteractiveOptions
  def initialize(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

  def call; end

  private

  def build_selection(char); end
  def calculate_option_line_lengths; end
  def chop_selection; end
  def clear_output(number_of_lines = T.unsafe(nil)); end
  def display_metadata?; end
  def distance_from_selection_to_end; end
  def distance_from_start_to_selection; end
  def down; end
  def ensure_first_item_is_continuation_marker; end
  def ensure_last_item_is_continuation_marker; end
  def ensure_visible_is_active; end
  def filtering?; end
  def format_choice(format, choice); end
  def has_filter?; end
  def index_of_active_option; end
  def max_lines; end
  def num_lines; end
  def presented_options(recalculate: T.unsafe(nil)); end
  def process_input_until_redraw_required; end
  def read_char; end
  def render_options; end
  def reset_position(number_of_lines = T.unsafe(nil)); end
  def select_bool(char); end
  def select_current; end
  def select_n(n); end
  def selecting?; end
  def start_filter; end
  def start_line_select; end
  def stop_line_select; end
  def terminal_width_changed?; end
  def up; end
  def update_search(char); end
  def wait_for_user_input; end

  class << self
    def call(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
  end
end

CLI::UI::Prompt::InteractiveOptions::BACKSPACE = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::CHECKBOX_ICON = T.let(T.unsafe(nil), Hash)
CLI::UI::Prompt::InteractiveOptions::CTRL_C = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::CTRL_D = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::DONE = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::ESC = T.let(T.unsafe(nil), String)

class CLI::UI::Prompt::OptionsHandler
  def initialize; end

  def call(options); end
  def option(option, &handler); end
  def options; end
end

CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

module CLI::UI::Spinner
  class << self
    def current_rune; end
    def index; end
    def index=(_arg0); end
    def spin(title, auto_debrief: T.unsafe(nil), &block); end
  end
end

class CLI::UI::Spinner::Async
  def initialize(title); end

  def stop; end

  class << self
    def start(title); end
  end
end

CLI::UI::Spinner::GLYPHS = T.let(T.unsafe(nil), Array)
CLI::UI::Spinner::PERIOD = T.let(T.unsafe(nil), Float)
CLI::UI::Spinner::RUNES = T.let(T.unsafe(nil), Array)

class CLI::UI::Spinner::SpinGroup
  def initialize(auto_debrief: T.unsafe(nil)); end

  def add(title, &block); end
  def debrief; end
  def wait; end
end

class CLI::UI::Spinner::SpinGroup::Task
  def initialize(title, &block); end

  def check; end
  def exception; end
  def render(index, force = T.unsafe(nil), width: T.unsafe(nil)); end
  def stderr; end
  def stdout; end
  def success; end
  def title; end
  def update_title(new_title); end

  private

  def full_render(index, terminal_width); end
  def glyph(index); end
  def inset; end
  def inset_width; end
  def partial_render(index); end
end

CLI::UI::Spinner::TASK_FAILED = T.let(T.unsafe(nil), Symbol)

module CLI::UI::StdoutRouter
  class << self
    def assert_enabled!; end
    def current_id; end
    def disable; end
    def duplicate_output_to; end
    def duplicate_output_to=(_arg0); end
    def enable; end
    def enabled?(stream = T.unsafe(nil)); end
    def ensure_activated; end
    def with_enabled; end
    def with_id(on_streams:); end

    private

    def activate(stream, streamname); end
    def deactivate(stream); end
  end
end

class CLI::UI::StdoutRouter::Capture
  def initialize(*block_args, with_frame_inset: T.unsafe(nil), &block); end

  def run; end
  def stderr; end
  def stdout; end

  class << self
    def with_stdin_masked; end
  end
end

class CLI::UI::StdoutRouter::Writer
  def initialize(stream, name); end

  def write(*args); end

  private

  def apply_line_prefix(str, prefix); end
  def auto_frame_inset?; end
  def prepend_id(stream, args); end
  def prepend_id_for_stream(stream); end
end

module CLI::UI::Terminal
  class << self
    def height; end
    def setup_winsize_trap; end
    def width; end
    def winsize; end
  end
end

CLI::UI::Terminal::DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)
CLI::UI::Terminal::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

module CLI::UI::Truncater
  class << self
    def call(text, printing_width); end

    private

    def width(printable_codepoint); end
  end
end

CLI::UI::Truncater::EMOJI_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::ESC = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::LC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::NUMERIC_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::PARSE_ANSI = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ESC = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ROOT = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ZWJ = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::SEMICOLON = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::TRUNCATED = T.let(T.unsafe(nil), String)
CLI::UI::Truncater::UC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::ZWJ = T.let(T.unsafe(nil), Integer)

module CLI::UI::Widgets
  class << self
    def available; end
    def lookup(handle); end
    def register(name, &cb); end
  end
end

class CLI::UI::Widgets::Base
  def initialize(argstring); end

  class << self
    def argparse_pattern; end
    def call(argstring); end
  end
end

class CLI::UI::Widgets::InvalidWidgetArguments < ::ArgumentError
  def initialize(argstring, pattern); end

  def message; end
end

class CLI::UI::Widgets::InvalidWidgetHandle < ::ArgumentError
  def initialize(handle); end

  def message; end
end

CLI::UI::Widgets::MAP = T.let(T.unsafe(nil), Hash)

class CLI::UI::Widgets::Status < ::CLI::UI::Widgets::Base
  def render; end

  private

  def colorize_if_nonzero(num_str, rune, color); end
  def failed_part; end
  def pending_part; end
  def succeeded_part; end
  def working_part; end
  def zero?(num_str); end
end

CLI::UI::Widgets::Status::ARGPARSE_PATTERN = T.let(T.unsafe(nil), Regexp)
CLI::UI::Widgets::Status::ARROW = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::CLOSE = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::COMMA = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::EMPTY_SET = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::OPEN = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::SPINNER_STOPPED = T.let(T.unsafe(nil), String)

class CLI::UI::Wrap
  def initialize(input); end

  def wrap; end
end
